/*
 * main.c
 *
 *  Created on: 12 lis 2015
 *      Author: Bartek
 */

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdio.h>
#include "BMP180/BMP180.h"
#include "I2C/I2C.h"
//#include "RTC/RTC.h"
#include "MKUART/mkuart.h"
#include "HTU21D/HTU21D.h"
#include "BH1750/BH1750.h"
#include "ESP8266_CL/ESP8266_Cl.h"
#include "main.h"
#include "AVG/AVG.h"
#include "ThingSpeak/ThingSpeak.h"
#define SIZE 8
#define MASK (SIZE-1)


volatile uint8_t trigger_counter;
volatile uint8_t reset_counter;

volatile uint8_t trigger_flag;	/* Flaga zezwolenia na wyzwolenie pomiarow */
volatile uint8_t reset_connection_flag;

volatile int8_t  temperature[SIZE];
volatile uint16_t illuminance[SIZE];
volatile uint8_t humidity[SIZE];
volatile int32_t pressure[SIZE];

volatile int8_t  temperature_avg;
volatile int32_t pressure_avg;
volatile uint16_t illuminance_avg;
volatile uint8_t humidity_avg;



uint8_t getHumidity()
{
	uint8_t humidity;

	HTU21D_StartHumidity();
	_delay_ms(15);
	humidity = HTU21D_GetHumidity();

	return humidity;
}


int8_t getTemperature()
{
	int8_t temperature_int;
	uint8_t temperature_fract;

	HTU21D_StartTemperature();
	_delay_ms(15);
	HTU21D_GetTemperature(&temperature_int, &temperature_fract);

	return temperature_int;

}

uint16_t getIlluminance()
{
	uint16_t illuminance;

	BH1750_Start(BH1750_OTHR_MODE2);
	_delay_ms(150);
	illuminance = BH1750_Read();

	return illuminance;
}

long temp, press;









void configInterrupt()
{

	//Dla 328P
	//EICRA = (1 << ISC01) | (1 << ISC00);	//Zbocze rosnace
	//EIMSK = 1 << INT0;
}


void initializeTimers()
{



	//Dla 328P
//	TCCR1B = (1<<WGM12) |
//			 (1<<CS12);  //Preskaler 1024    7372800/1024=7200
//	OCR1A = 7200;
//	TIMSK1 = 1 << OCIE1A;   //Aktywowanie przerwan CTC OCR1A
}

void initializeModules()
{
	//ESP_Init();
	//HTU21D_Init(Humidity10b_Temperature13b);
	//BMP180_Init(BMP180_Mode_ULP);


//	RTC_InitTypeDef RTC_Struct;
//	RTC_Struct.RTC_Oscillator = DISABLE;
//	RTC_Struct.RTC_Alarm1 = Alarm1_OncePerSec;
//	RTC_Struct.RTC_Alarm2= Alarm2_OncePerMin;
//	RTC_Struct.BB_SQW = DISABLE;
//	RTC_Struct.RTC_SQW = SQW_Disable;
//	RTC_Init(&RTC_Struct);
//	RTC_AlarmTypedef RTC_AlarmStruct;
//	RTC_AlarmStruct.seconds=30;
//	RTC_SetAlarm(&RTC_AlarmStruct);
}


void sendTemperature(int8_t temperature)
{
	char value[7];
	sprintf(value, "%d", temperature);
	TS_UpdateField(value, 1);
}

void sendHumidity(uint8_t humidity)
{
	char value[7];
	sprintf(value, "%d", humidity);
	TS_UpdateField(value, 2);
}

void sendPressure(int32_t pressure)
{
	char value[7];
	sprintf(value, "%d", (int)(pressure/100));
	TS_UpdateField(value, 4);
}

void sendIlluminance(uint16_t illuminance)
{
	char value[7];
	sprintf(value, "%d", illuminance);
	TS_UpdateField(value, 4);
}


void initializeInterfaces()
{
	//TWI_Init(100000/100);
	USART_Init(__UBRR);
}


int main() {
	DDRB  = 1 << PB1;
	PORTB = 1 << PB1;
	trigger_counter = 0;
	//initializeInterfaces();
	//initializeModules();
	//configInterrupt();
	initializeTimers();


	for (int i = 0; i < SIZE; i++)
	{
		illuminance[i] = getIlluminance();
		temperature[i] = getTemperature();
		humidity[i]    = getHumidity();
	}

	humidity_avg = calcAVG_UINT8(humidity, SIZE);
	temperature_avg = calcAVG_INT8(temperature, SIZE);
	illuminance_avg = calcAVG_UINT16(illuminance, SIZE);



    sei();  // globalne odblokowanie przerwañ

   uart_puts("************** Dzien Dobry ******************\r\n");


	while(1) {
		PORTB ^= 1<<PB1;
		_delay_ms(2000);

		if (trigger_flag == MEASUREMENTS_TRIGGER_ENABLE)
		{

		}

		if (reset_counter % 5 == 0)
		{
			ESP_Disconnect();
			_delay_ms(2000);
			//ESP_ConnectServer(char* ip_address, char* port);
			_delay_ms(3000);
		}
//		//BMP180_StartTemp();
//		_delay_ms(60);
//		temp = BMP180_GetTemp();
//		//BMP180_StartPress();
//		//_delay_ms(60);
//		press = BMP180_GetPress();
//		SendToUart();
//		_delay_ms(5000);

	}
}



ISR(TIMER1_COMPA_vect)
{

	if (trigger_counter % 60 == 0)
	{
		trigger_counter = 0;
		reset_counter++;
		trigger_flag = MEASUREMENTS_TRIGGER_ENABLE;
	}
	if (reset_counter % 5 == 0)
	{
		reset_counter = 0;
		reset_connection_flag = RESET_CONNECTION_ENABLE;

	}
	PORTB ^= 1<<PB1;
	trigger_counter++;
}
